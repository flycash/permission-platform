// Code generated by MockGen. DO NOT EDIT.
// Source: ./general_consumer.go
//
// Generated by this command:
//
//	mockgen -source=./general_consumer.go -package=evtmocks -destination=../../event/mocks/kafka_consumer.mock.go -typed Consumer
//

// Package evtmocks is a generated GoMock package.
package evtmocks

import (
	reflect "reflect"
	time "time"

	kafka "github.com/confluentinc/confluent-kafka-go/v2/kafka"
	gomock "go.uber.org/mock/gomock"
)

// MockConsumer is a mock of Consumer interface.
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerMockRecorder
	isgomock struct{}
}

// MockConsumerMockRecorder is the mock recorder for MockConsumer.
type MockConsumerMockRecorder struct {
	mock *MockConsumer
}

// NewMockConsumer creates a new mock instance.
func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &MockConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumer) EXPECT() *MockConsumerMockRecorder {
	return m.recorder
}

// Assignment mocks base method.
func (m *MockConsumer) Assignment() ([]kafka.TopicPartition, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Assignment")
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Assignment indicates an expected call of Assignment.
func (mr *MockConsumerMockRecorder) Assignment() *MockConsumerAssignmentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Assignment", reflect.TypeOf((*MockConsumer)(nil).Assignment))
	return &MockConsumerAssignmentCall{Call: call}
}

// MockConsumerAssignmentCall wrap *gomock.Call
type MockConsumerAssignmentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerAssignmentCall) Return(partitions []kafka.TopicPartition, err error) *MockConsumerAssignmentCall {
	c.Call = c.Call.Return(partitions, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerAssignmentCall) Do(f func() ([]kafka.TopicPartition, error)) *MockConsumerAssignmentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerAssignmentCall) DoAndReturn(f func() ([]kafka.TopicPartition, error)) *MockConsumerAssignmentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitMessage mocks base method.
func (m_2 *MockConsumer) CommitMessage(m *kafka.Message) ([]kafka.TopicPartition, error) {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "CommitMessage", m)
	ret0, _ := ret[0].([]kafka.TopicPartition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitMessage indicates an expected call of CommitMessage.
func (mr *MockConsumerMockRecorder) CommitMessage(m any) *MockConsumerCommitMessageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitMessage", reflect.TypeOf((*MockConsumer)(nil).CommitMessage), m)
	return &MockConsumerCommitMessageCall{Call: call}
}

// MockConsumerCommitMessageCall wrap *gomock.Call
type MockConsumerCommitMessageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerCommitMessageCall) Return(arg0 []kafka.TopicPartition, arg1 error) *MockConsumerCommitMessageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerCommitMessageCall) Do(f func(*kafka.Message) ([]kafka.TopicPartition, error)) *MockConsumerCommitMessageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerCommitMessageCall) DoAndReturn(f func(*kafka.Message) ([]kafka.TopicPartition, error)) *MockConsumerCommitMessageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pause mocks base method.
func (m *MockConsumer) Pause(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pause", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pause indicates an expected call of Pause.
func (mr *MockConsumerMockRecorder) Pause(partitions any) *MockConsumerPauseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pause", reflect.TypeOf((*MockConsumer)(nil).Pause), partitions)
	return &MockConsumerPauseCall{Call: call}
}

// MockConsumerPauseCall wrap *gomock.Call
type MockConsumerPauseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerPauseCall) Return(err error) *MockConsumerPauseCall {
	c.Call = c.Call.Return(err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerPauseCall) Do(f func([]kafka.TopicPartition) error) *MockConsumerPauseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerPauseCall) DoAndReturn(f func([]kafka.TopicPartition) error) *MockConsumerPauseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Poll mocks base method.
func (m *MockConsumer) Poll(timeoutMs int) kafka.Event {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Poll", timeoutMs)
	ret0, _ := ret[0].(kafka.Event)
	return ret0
}

// Poll indicates an expected call of Poll.
func (mr *MockConsumerMockRecorder) Poll(timeoutMs any) *MockConsumerPollCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Poll", reflect.TypeOf((*MockConsumer)(nil).Poll), timeoutMs)
	return &MockConsumerPollCall{Call: call}
}

// MockConsumerPollCall wrap *gomock.Call
type MockConsumerPollCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerPollCall) Return(event kafka.Event) *MockConsumerPollCall {
	c.Call = c.Call.Return(event)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerPollCall) Do(f func(int) kafka.Event) *MockConsumerPollCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerPollCall) DoAndReturn(f func(int) kafka.Event) *MockConsumerPollCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadMessage mocks base method.
func (m *MockConsumer) ReadMessage(timeout time.Duration) (*kafka.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadMessage", timeout)
	ret0, _ := ret[0].(*kafka.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadMessage indicates an expected call of ReadMessage.
func (mr *MockConsumerMockRecorder) ReadMessage(timeout any) *MockConsumerReadMessageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadMessage", reflect.TypeOf((*MockConsumer)(nil).ReadMessage), timeout)
	return &MockConsumerReadMessageCall{Call: call}
}

// MockConsumerReadMessageCall wrap *gomock.Call
type MockConsumerReadMessageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerReadMessageCall) Return(arg0 *kafka.Message, arg1 error) *MockConsumerReadMessageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerReadMessageCall) Do(f func(time.Duration) (*kafka.Message, error)) *MockConsumerReadMessageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerReadMessageCall) DoAndReturn(f func(time.Duration) (*kafka.Message, error)) *MockConsumerReadMessageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Resume mocks base method.
func (m *MockConsumer) Resume(partitions []kafka.TopicPartition) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resume", partitions)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resume indicates an expected call of Resume.
func (mr *MockConsumerMockRecorder) Resume(partitions any) *MockConsumerResumeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resume", reflect.TypeOf((*MockConsumer)(nil).Resume), partitions)
	return &MockConsumerResumeCall{Call: call}
}

// MockConsumerResumeCall wrap *gomock.Call
type MockConsumerResumeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConsumerResumeCall) Return(err error) *MockConsumerResumeCall {
	c.Call = c.Call.Return(err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConsumerResumeCall) Do(f func([]kafka.TopicPartition) error) *MockConsumerResumeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConsumerResumeCall) DoAndReturn(f func([]kafka.TopicPartition) error) *MockConsumerResumeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
