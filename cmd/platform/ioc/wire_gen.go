// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package ioc

import (
	rbac2 "gitee.com/flycash/permission-platform/internal/api/grpc/rbac"
	audit2 "gitee.com/flycash/permission-platform/internal/event/audit"
	"gitee.com/flycash/permission-platform/internal/event/permission"
	"gitee.com/flycash/permission-platform/internal/ioc"
	"gitee.com/flycash/permission-platform/internal/repository"
	"gitee.com/flycash/permission-platform/internal/repository/cache"
	"gitee.com/flycash/permission-platform/internal/repository/dao"
	"gitee.com/flycash/permission-platform/internal/repository/dao/audit"
	"gitee.com/flycash/permission-platform/internal/service/rbac"
	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/google/wire"
	"github.com/gotomicro/ego/core/econf"
)

// Injectors from wire.go:

func InitApp() *ioc.App {
	v := ioc.InitDB()
	businessConfigDAO := dao.NewBusinessConfigDAO(v)
	businessConfigRepository := repository.NewBusinessConfigRepository(businessConfigDAO)
	resourceDAO := dao.NewResourceDAO(v)
	resourceRepository := repository.NewResourceRepository(resourceDAO)
	permissionDAO := dao.NewPermissionDAO(v)
	permissionRepository := repository.NewPermissionRepository(permissionDAO)
	roleDAO := dao.NewRoleDAO(v)
	roleRepository := repository.NewRoleRepository(roleDAO)
	roleInclusionDAO := dao.NewRoleInclusionDAO(v)
	roleInclusionDefaultRepository := repository.NewRoleInclusionDefaultRepository(roleInclusionDAO)
	userRoleDAO := dao.NewUserRoleDAO(v)
	userRoleDefaultRepository := repository.NewUserRoleDefaultRepository(userRoleDAO)
	rolePermissionDAO := dao.NewRolePermissionDAO(v)
	userPermissionDAO := dao.NewUserPermissionDAO(v)
	userPermissionDefaultRepository := repository.NewUserPermissionDefaultRepository(roleInclusionDAO, rolePermissionDAO, userRoleDAO, userPermissionDAO)
	cmdable := ioc.InitRedisCmd()
	ecacheCache := ioc.InitLocalCache()
	component := ioc.InitEtcdClient()
	v2 := ioc.InitCacheKeyFunc()
	cacheCache := ioc.InitMultipleLevelCache(cmdable, ecacheCache, userPermissionDefaultRepository, component, v2)
	userPermissionCache := cache.NewUserPermissionCache(cacheCache, v2)
	producer := ioc.InitKafkaProducer()
	userPermissionEventProducer := initUserPermissionEventProducer(producer)
	userPermissionCachedRepository := repository.NewUserPermissionCachedRepository(userPermissionDefaultRepository, userPermissionCache, userPermissionEventProducer)
	roleInclusionReloadCacheRepository := repository.NewRoleInclusionReloadCacheRepository(roleInclusionDefaultRepository, userRoleDefaultRepository, userPermissionCachedRepository)
	rolePermissionDefaultRepository := repository.NewRolePermissionDefaultRepository(rolePermissionDAO)
	rolePermissionReloadCacheRepository := repository.NewRolePermissionReloadCacheRepository(rolePermissionDefaultRepository, roleInclusionDAO, userRoleDAO, userPermissionCachedRepository)
	userRoleReloadCacheRepository := repository.NewUserRoleReloadCacheRepository(userRoleDefaultRepository, userPermissionCachedRepository)
	token := ioc.InitJWTToken()
	service := rbac.NewService(businessConfigRepository, resourceRepository, permissionRepository, roleRepository, roleInclusionReloadCacheRepository, rolePermissionReloadCacheRepository, userRoleReloadCacheRepository, userPermissionCachedRepository, token)
	server := rbac2.NewServer(service)
	permissionService := rbac.NewPermissionService(userPermissionCachedRepository)
	permissionServiceServer := rbac2.NewPermissionServiceServer(permissionService)
	operationLogDAO := audit.NewOperationLogDAO(v)
	v3 := ioc.InitGRPC(server, permissionServiceServer, token, operationLogDAO)
	userRoleLogDAO := audit.NewUserRoleLogDAO(v)
	userRoleBinlogEventConsumer := initUserRoleBinlogEventConsumer(userRoleLogDAO)
	v4 := ioc.InitTasks(userRoleBinlogEventConsumer)
	app := &ioc.App{
		GrpcServers: v3,
		Tasks:       v4,
	}
	return app
}

// wire.go:

var (
	baseSet    = wire.NewSet(ioc.InitDB, ioc.InitEtcdClient, ioc.InitIDGenerator, ioc.InitRedisClient, ioc.InitLocalCache, ioc.InitRedisCmd, ioc.InitJWTToken, ioc.InitMultipleLevelCache, ioc.InitCacheKeyFunc, ioc.InitKafkaProducer)
	rbacSvcSet = wire.NewSet(rbac.NewService, rbac.NewPermissionService, dao.NewBusinessConfigDAO, repository.NewBusinessConfigRepository, dao.NewResourceDAO, repository.NewResourceRepository, dao.NewPermissionDAO, repository.NewPermissionRepository, dao.NewRoleDAO, repository.NewRoleRepository, dao.NewRoleInclusionDAO, repository.NewRoleInclusionDefaultRepository, repository.NewRoleInclusionReloadCacheRepository, wire.Bind(new(repository.RoleInclusionRepository), new(*repository.RoleInclusionReloadCacheRepository)), dao.NewRolePermissionDAO, repository.NewRolePermissionDefaultRepository, repository.NewRolePermissionReloadCacheRepository, wire.Bind(new(repository.RolePermissionRepository), new(*repository.RolePermissionReloadCacheRepository)), dao.NewUserRoleDAO, repository.NewUserRoleDefaultRepository, repository.NewUserRoleReloadCacheRepository, wire.Bind(new(repository.UserRoleRepository), new(*repository.UserRoleReloadCacheRepository)), dao.NewUserPermissionDAO, repository.NewUserPermissionDefaultRepository, cache.NewUserPermissionCache, repository.NewUserPermissionCachedRepository, wire.Bind(new(repository.UserPermissionRepository), new(*repository.UserPermissionCachedRepository)), wire.Bind(new(repository.UserPermissionCacheReloader), new(*repository.UserPermissionCachedRepository)), audit.NewUserRoleLogDAO, audit.NewOperationLogDAO, initUserRoleBinlogEventConsumer,
		initUserPermissionEventProducer,
	)
)

func initUserRoleBinlogEventConsumer(dao2 audit.UserRoleLogDAO) *audit2.UserRoleBinlogEventConsumer {
	type Consumer struct {
		GroupID string `yaml:"groupId"`
	}
	type Config struct {
		Topic    string   `yaml:"topic"`
		Consumer Consumer `yaml:"consumer"`
	}
	var cfg Config
	err := econf.UnmarshalKey("userRoleBinlogEvent", &cfg)
	if err != nil {
		panic(err)
	}
	eventConsumer, err := audit2.NewUserRoleBinlogEventConsumer(ioc.InitKafkaConsumer(cfg.Consumer.GroupID), dao2, cfg.Topic)
	if err != nil {
		panic(err)
	}
	return eventConsumer
}

func initUserPermissionEventProducer(producer *kafka.Producer) permission.UserPermissionEventProducer {
	type Config struct {
		Topic string `yaml:"topic"`
	}
	var cfg Config
	err := econf.UnmarshalKey("userPermissionEvent", &cfg)
	if err != nil {
		panic(err)
	}
	p, err := permission.NewUserPermissionEventProducer(producer, cfg.Topic)
	if err != nil {
		panic(err)
	}
	return p
}
